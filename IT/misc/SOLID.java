/**
 * https://sergeyteplyakov.blogspot.com/2014/10/solid.html
 * ------------------------------------------------------------------------------
 *
 * 1. Single Responsibility
 * 2. Open/Closed
 * 3. Liskov Substitution
 * 4. Interface Segregation
 * 5. Dependency Inversion
 *
 *------------------------------------------------------------------------------
 *
 *   1. Single Responsibility Principle
 *      Принцип единственной ответственности
 *
 *      Класс должен иметь только одну ответсвенность.
 *      Более того, класс должен иметь одну причину для изменения.
 *
 *      Преимущества:
 *        Тестирование - класс с единственной ответсвенностью имеет меньше
 *                       тестовых случаев
 *        Организация - небольшие, хорошо организованные классы легче читать,
 *                      чем монолитные.
 *        Меньшая связанность - меньшая функциональность в одном классе будет
 *                              иметь меньше зависимостей
 *
 *     Короче,
 *     SRP – это способ поиска скрытых абстракций, достаточно сложных,
 *           чтобы им отвели отдельную именованную сущность и спрятали в их
 *           недрах все детали.
 *
 *     https://sergeyteplyakov.blogspot.com/2014/08/single-responsibility-principle.html
 *
 *
 *------------------------------------------------------------------------------
 *
 *
 *    2. Open-Closed Principle
 *       Принцип открытости-закрытости
 *
 *       Класс должен быть открыт для расширение и закрыт для изменения.
 *       Таким образом, не внося изменения в существующий код, мы избегаем
 *       появление новых багов.
 *
 *       https://sergeyteplyakov.blogspot.com/2014/08/open-closed-principle.html
 *
 *
 *------------------------------------------------------------------------------
 *
 *
 *    3. Liskov Substitution Principle
 *       Принцип Барбары Лисков
 *
 *       Если класс Б подтип класса А, мы можем заменить А на Б без изменения
 *       поведения нашей программы.
 *
 *       https://sergeyteplyakov.blogspot.com/2014/09/liskov-substitution-principle.html
 *
 *
 *------------------------------------------------------------------------------
 *
 *
 *    4. Interface Segregation Principle
 *       Принцип разделения интерфейсов
 *
 *       Большие интерфейсы должны быть разделены на интерфейсы поменьше.
 *       Это позволит нам реализовывать в классах только те методы, которые им
 *       нужны.
 *
 *       https://sergeyteplyakov.blogspot.com/2014/08/interface-segregation-principle.html
 *
 *
 *------------------------------------------------------------------------------
 *
 *
 *    5. Dependency Inversion Principle
 *       Принцип инверсии зависимости.
 *
 *       Вместо того, чтоб модули были связаны на низком уровне, они должны быть
 *       связаны на высоком уровне, то есть должны зависить от абстракции, а не
 *       от реализации.
 *
 *       ! Не путать с DI - Dependency Injection !
 *
 *       https://sergeyteplyakov.blogspot.com/2014/09/the-dependency-inversion-principle.html
 *
 *------------------------------------------------------------------------------
 */