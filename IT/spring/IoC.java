/**
 * Многослойная архитектура
 *
 * Пользователь <---> Presentation Layer <---> Business Layer <---> DataAccessLayer <---> Database
 *
 */

/**
 * IoC (inversion of control)
 *
 *  Общее понятие, которое отличает библиотеку от фреймворка.
 *  Классическая модель подразумевает, что код котролирует внешнее окружение
 *  и время и порядок вызова библиотечных методов.
 *
 *  В случае фреймворка обязанности меняются местами: фреймворк предоставляет
 *  точки расширения, через которые он вызывает определенные методы
 *  пользовательского кода.
 *
 *  Простой метод обратного вызова или любая другая форма паттерна
 *  Наблюдатель является примером инверсии.
 *
 *
 * Голивудский принцип - не звоните мне, я сам вам позвоню.
 *
 * IoC в применении к классам называется DI (dependency injection)
 *
 *      IoC/DI
 *
 *          - упрощает переиспользование компонентов
 *          - упрощает unit-тестирование
 *          - чистый код - только бизнес логика
 *
 *
 *  Инверсия управления (IoC) говорит об изменении потока исполнения, присуща
 *  фреймворкам и функциям обратного вызова и не имеет никакого отношения к
 *  управлению зависимостями.
 *
 *  Передача зависимостей (DI) - это инструмент передачи классу его
 *  зависимости через конструктор, метод или свойство.
 *
 *  https://sergeyteplyakov.blogspot.com/2014/11/di-vs-dip-vs-ioc.html
 */


/**
 *  Классический способ
 *
 *              + --> IPersonDAO <- +
 *             |                     \
 *            |                       \
 *    PersonService    -------->    PersonDAO
 *
 *           A --> B
 *
 * Проблемы этого кода
 * 1. невозможно заменить реализацию PersonDAO на другую
 * 2. класс PersonService напрямую зависит от PersonDAO
 * 3. невозможно тестировать PersonService отдельно от PersonDAO
 * 4. жизненый цикл классов всязан напрямую
 */


class PersonService {
    private final IPersonDAO dao;

    public PersonService(){
        this.dao = new PersonDAO("127.0.0.1:80");
    }
}

class PersonDAO implements IPersonDAO {
    private final String url;

    public PersonDAO(String url){
        this.url = url;
    }
}







/**
 * Паттерн ServiceLocator
 *
 *
 *
 *              + --> IPersonDAO <-- +
 *             |                      \
 *            |                        \
 *    PersonService                PersonDAO
 *           \
 *            \
 *             + --> ServiceLocator
 *
 *       A                              B
 *        \                            /
 *         \                          /
 *          + --> ServiceLocator <-- +
 *
 *   PersenService звонит ServiceLocator
 *
 * Плюсы
 * 1. PersonService не зависит от PersonDAO
 * 2. PersonService можно тестировать отдельно от PersonDAO (если постараться)
 * 3. PersonDAO можно заменить на другую реализацию
 *
 */

class PersonService {
    private final IPersonDAO dao;

    public PersonService(){
        this.dao = ServiceLocator.getPersonDAO();
    }
}

class PersonDAO implements IPersonDAO {
    private final String url;

    public PersonDAO(String url){
        this.url = url;
    }
}




/**
 * IoC container
 *
 *              + --> IPersonDAO <-- +
 *             |                      \
 *            |                        \
 *    PersonService                PersonDAO
 *           \
 *            \
 *             + --> IoC container
 *
 *
 *         A <-- +             + --> B
 *                \           /
 *                 \         /
 *                IoC container
 *
 *        PersonService никому не звонит, он ждет чтоб ему позвонили
 *
 *
 * Плюсы
 * 1. контейнер создает необходимые объекты и управляет жизненым циклом
 *
 */

class PersonService {
    private final IPersonDAO dao;

    public PersonService(IPersonDao dao){
        this.dao = dao;
    }
}

class PersonDAO implements IPersonDAO {
    private final String url;

    public PersonDAO(String url){
        this.url = url;
    }
}


--------------------------------------------------------------------------------


/**
 * Источник https://www.youtube.com/watch?v=c0pxYhkXLAU&ab_channel=S0ER
 *
 * IoC - принцип ООП, которая позволяет уменьшить связность в программе, тем самым уменьшая ее сложность и обычно реализуе в фреймфорках, чтоб забрать управление у клиентского кода и самостоятелно в рамках фреймворка определить что, где, когда должно выполняться и как обрабатываться. Передача управление внешнему источнику.
 *
 * Также архитектурное решение интеграции, упрощающее расширение возможностей системы, при котором поток управления программы контролируется фреймворком.
 *
 * В классической схеме работы приложения программист полностью управляет потоком работы приложения.
 *
 * Фреймворк, напротив, берет управление потоком на себя и вызывает ваш код тогда, когда это потребуется.
 *
 * Происходит уреря контроля над выполнением кода - это и называется инверсией управления.
 *
 * Фреймворк управляет кодом программиста, а не программист управляет фреймворком.
 *
 * IoC - набор рекомендаций для написания слабо связанного кода.
 *
 * Слабо связанный код предполагает что каждый компонент системы должен быть как можно более изолированым от других и не полагаться на детали конкретной реализации других компонентов.
 *
 * DI - механизм передачи классу его зависимостей.
 *
 * IoC - principle - принцип, набор рекомендаций
 * DI - pattern - один из способов реализации IoC
 * IoC Container - framework - приложение, реализующее IoC
 *
 * IoC Container - объект, который занимается созданием других объектов и внедрением в них зависимостей.
 */